---
title: "Visualizing Star Wars"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    css: resources/css/custom.css
    logo: resources/images/jedi_logo.png
    favicon: resources/images/jedi_fav.png
---

```{r setup, include = FALSE}
# load necessary packages (if you do not have them, you will need to install them first)
library(flexdashboard) # for creating the flex dashboard. 
library(DT) # for creating table html widgets
library(tidyverse) # for dataframe manipulation and plotting
library(magrittr) # for updating an object that is piped into a function (using `%<>%`)
library(here) # for finding the project folder
library(repurrrsive) # contains the star wars datasets
library(rlist) # for binding all lit elements by column (using `list.cbind`)
library(ggrepel) # for adding geom_text labels that do not overlap
library(gganimate) # for animating the plot

# add gravitational constant (i.e., 6.67408 * 10^-11)
grav_constant <- 6.67408 * (10 ^ -11)

# load bespoke functions from the functions folder
source(here("resources/functions/my_theme.R")) # load my_theme
source(here("resources/functions/geom_saberhilt.R")) # load the function for creating the hilts of lightsabers
source(here("resources/functions/geom_saberblade.R")) # load the function for creating the blades of lightsabers

# set figure output dimensions
knitr::opts_chunk$set(fig.width  = 12, 
                      fig.height = 8)
```

# The Data {.storyboard data-icon="fa-database"}

### Introducing the Data

```{r introduction}
knitr::include_graphics(here("resources/images/swapi.png"))
```

***
Welcome! 

This portfolio shows the development of three different visualizations 
of the Star Wars universe. The [first visualization][The People] shows the average age of characters in the universe bifurcated by gender. The [second visualization][The Starships] demonstrates how starship classes differ in terms of length. The [third visualization][The Planets] illustrates the distance of Star War's planet from their host stars and animates their orbital periods. Planets from our solar system are included for easy comparison.

All of the data for the visualizations are from [Jenny Bryan](https://github.com/jennybc)'s  [repurrrsive](https://github.com/jennybc/repurrrsive) package. The [repurrrsive](https://github.com/jennybc/repurrrsive) package includes various datasets to assist in the teaching of R. The Star Wars dataset is originally from [SWAPI](https://swapi.co) (i.e., the Star Wars API).

### The People Data

```{r load_people_data}
# load and format data
people <- data.frame(t(list.cbind(sw_people))) %>%
  # convert the star wars people dataframe to a tibble
  as_tibble() %>%
  # select only the columns between name and gender (inclusive)
  select(name:gender) %>%
  # mutates columns that are lists to non-lists
  mutate_if(is.list, ~(unlist(.))) %>%
  # mutate all columns and replaces the text "unknown" with "NA"
  mutate_all(~(na_if(., "unknown"))) %>%
  # converts height and mass to numeric variables
  mutate_at(vars(height, mass), ~(as.numeric(.))) %>%
  # extracts birth year and converts it to numeric; replace "n/a" values with 
  # droid for hair_color and gender
  mutate(birth_year = parse_number(as.character(birth_year)),
         hair_color = if_else(gender == "n/a", "droid", hair_color),
         gender     = if_else(gender == "n/a", "droid", gender))

# embed the data
datatable(people)
```

*** 

In order to get the people data into the correct format for our visualization, I first made a `tibble` of the data from [repurrrsive](https://github.com/jennybc/repurrrsive)'s `sw_people` dataset. I selected only those columns of interest and unlisted the columns (all of the data in [repurrrsive](https://github.com/jennybc/repurrrsive) is, as the name would suggest, stored in recursive lists). I then converted the variables to the correct variable types and replaced "n/a" with more meaningful values. I also used `parse_number` to extract the characters' ages from their birth year. Although the number actually refers to how many years before or after the Battle of Yavin a character was born, all characters that had values for `birth_year` were born before the Battle of Yavin. Therefore, the result of `parse_number` provided all of the characters' ages at the Battle of Yavin.

### The Starships Data

```{r load_starships_data, warning = FALSE}
# load and format data
starships <- data.frame(t(list.cbind(sw_starships))) %>%
  # convert the star ways starship dataset to a tibble
  as_tibble() %>%
  # clean column names
  janitor::clean_names() %>%
  # select only those columns between name and starship (inclusive)
  select(name:starship_class) %>%
  # mutate columns that are lists to non-lists
  mutate_if(is.list, ~(unlist(.))) %>%
  # mutate all columns, replacing "unknown" with "NA"  
  mutate_all(~(na_if(., "unknown"))) %>%
  # convert numeric columns to numerics
  mutate_at(vars(cost_in_credits,
                 length,
                 crew,
                 passengers,
                 cargo_capacity,
                 hyperdrive_rating,
                 mglt), ~(as.numeric(.))) %>%
  # extract the max_atmosphering_speed and convert starship_class to a lowercase
  # factor
  mutate(max_atmosphering_speed = parse_number(max_atmosphering_speed),
         starship_class         = as.factor(tolower(starship_class))) %>%
  # seperate consumables into a value and unit (e.g., days, weeks, months, 
  # years)
  separate(consumables, c("con_n", "con_unit"), sep = " ") %>%
  # convert units to numeric values and multiply with the consumable value to 
  # provide the amount of consumable in the total number of days
  mutate(con_unit    = case_when(str_detect(con_unit,  "hour") ~  ".0417",
                                 str_detect(con_unit,   "day") ~      "1",
                                 str_detect(con_unit,  "week") ~      "7",
                                 str_detect(con_unit, "month") ~     "30",
                                 str_detect(con_unit,  "year") ~    "365"),
         consumables = as.numeric(con_n) * as.numeric(con_unit)) %>%
  # retain only the new consumables column (i.e., drop con_n and con_unit)
  select(-starts_with("con_"))

# embed the data
datatable(starships)
```

*** 

To get the data into the correct format for the starship visualization, I again created a `tibble` of the data from [repurrrsive](https://github.com/jennybc/repurrrsive)'s `sw_starships` dataset and unlisted the columns that were stored as lists. I converted all numeric variables to be numeric. Consumables (i.e., the amount of food and life-preserving resources the ship can hold) had a rather odd format: the variable had both a number and a unit (e.g., 1 month, 3 years, 1 week, 5 days). To address this, I used `separate` to first split the integer (e.g., 1, 3, 1, 5) from the unit of time (month, years, week, days). I then converted the unit to the number of days it represented using a combination of `case_when` and `str_detect`. I used `str_detect` to account for singulars and plurals in the units of time (e.g., 1 day vs 15 days). I then multiplied the integer and the unit of time together to create the number of days the starship had consumables for. 

### The Planets Data

```{r load_planets_data, warning = FALSE}
# load and format data
planets <- data.frame(t(list.cbind(sw_planets))) %>%
  # convert star wars planets dataset to a tibble
  as.tibble() %>%
  # retain only columns between name and population (inclusive)
  select(name:population) %>%
  # mutate columns that are lists to non-lists
  mutate_if(is.list, ~(unlist(.))) %>%
  # mutate all columns, replacing "unknown" with "NA"  
  mutate_all(~(na_if(., "unknown"))) %>%
  # convert numeric columns to type numeric
  mutate_at(vars(rotation_period,
                 orbital_period,
                 diameter,
                 surface_water,
                 population),
            ~(as.numeric(.))) %>%
  # calculate values of interest
  mutate(
         # make surface water a proportion
         surface_water   = surface_water / 100,
         # calculate population in millions
         population_mils = population / 1000000,
         # calculate a planet's distance from the sun (Kepler's 3rd law)
         au              = (((orbital_period / 365) ^ 2) ^ (1/3)),
         # convert gravity to a number
         gravity         = parse_number(as.character(gravity)),
         # calculate the force of gravity
         g               = gravity * 9.8, 
         # calculate radius
         radius          = diameter / 2, 
         # calculate planet mass (ish)
         mass            = (g * (radius^2)) / grav_constant,
         # calculate planet area
         area            = pi * (radius^2),
         # create column indicating whether the planet is in the solar system
         solar_system    = rep(FALSE, n()),
         # create a new variable indicating whether a planet was in the original 
         # trilogy
         orig_tril = case_when(name == "Alderaan" |
                               name == "Tatooine" |
                               name == "Yavin"    |
                               name == "Yavin 4"  ~ "new_hope",
                               name == "Bespin"   |
                               name == "Dagobah"  |                     
                               name == "Hoth"     ~ "empire_strikes",    
                               name == "Endor"    ~ "return_jedi",
                               TRUE ~ NA_character_))

# create dataset for planets in the solar system
sol_sys <- tibble(
  name           = c("Mercury", "Venus", "Earth", "Mars", "Jupiter"),
  orbital_period = c(       88,     225,     365,    687,      4330),
  au             = c(      .39,     .72,       1,   1.52,      5.20),
  solar_system   = c(     TRUE,    TRUE,    TRUE,   TRUE,      TRUE),
  radius         = c(   2439.5,    6052,    6378,   3396,     71492)
)

#combine the star war's planets and solar system data into one dataset
planets <- bind_rows(planets, sol_sys)

# embed the data
datatable(planets) 
```

*** 

Again, I converted `repurrrsive`'s `sw_planets` dataset to a `tibble`, unlisted the list columns, and converted the numeric variables to numerics. 

When I cleaned the variables, I wasn't exactly sure what variables I was going to use for my plot, so I ended up creating a lot of additional variables that I thought may be interesting. Of direct use to my final plot, calculated the planets' distance from their star using Kepler's Third Law (i.e., ["The squares of the sidereal periods (of revolution) of the planets are directly proportional to the cubes of their mean distances from the Sun"](https://www.britannica.com/science/Keplers-laws-of-planetary-motion)). Essentially, the distance of a planet from its star is proportional to the length of its year. In this case, I used Astronomical Units (AU; ~150,000,000 km) to represent the distance from the star to the planet. Using astronomical units is helpful in this case because they are far more manageable and, since the distance from the Earth to the Sun is approximately 1 AU, they are far more interpretable. [Although, if one is able to hold the thought of 1,636,025,600 football fields in their head, that would also be an option](https://www.reddit.com/r/memes/comments/a7hnx7/daaaaaaaaamn_never_knew_that/).

I also added a column indicated whether the planet was featured in the original trilogy using data from the little-known-yet-highly-reputable website [Wikipedia](https://en.wikipedia.org/wiki/List_of_Star_Wars_planets_and_moons). I also used data from a small start-up [NASA](https://nssdc.gsfc.nasa.gov/planetary/factsheet/) and [Ask an Astronomer](http://curious.astro.cornell.edu/about-us/56-our-solar-system/planets-and-dwarf-planets/general-questions/214-how-far-is-each-planet-from-earth-intermediate) to add the first five planets in the Solar System, including their AUs, orbital periods, and their radii. 

# The People {.storyboard data-icon="fa-user-astronaut"}

### Version One

```{r people_viz_v1}
# people plot
people %>%
  filter(gender == "male" | gender == "female" | gender == "droid") %>%
  group_by(gender) %>%
  summarise(m_age = mean(birth_year, na.rm = TRUE)) %>%
  ggplot(aes(x = factor(gender), y = m_age, fill = factor(gender))) +
    geom_col(width = 0.10) +
    geom_col(width = 0.12, alpha = .6) +
    geom_col(width = 0.14, alpha = .4) +
    geom_col(width = 0.16, alpha = .2) +
    geom_col(width = 0.18, alpha = .1) +
    scale_fill_manual(values = c("#0FFF00", "#FF0000", "#000CFF")) +
    geom_rect(aes(ymin = -10, 
                  ymax = 0, 
                  xmin = .95,
                  xmax = 1.05),
              fill = "gray30") +
    geom_rect(aes(ymin = -10, 
                  ymax = 0, 
                  xmin = 1.95,
                  xmax = 2.05),
              fill = "gray30") +
    geom_rect(aes(ymin = -10, 
                  ymax = 0, 
                  xmin = 2.95,
                  xmax = 3.05),
              fill = "gray30") +
    geom_rect(aes(ymin = -5, 
                  ymax = -20, 
                  xmin = .94,
                  xmax = 1.06),
              fill = "gray30") +
    geom_rect(aes(ymin = -5, 
                  ymax = -20, 
                  xmin = 1.94,
                  xmax = 2.06),
              fill = "gray30") +
    geom_rect(aes(ymin = -5, 
                  ymax = -20, 
                  xmin = 2.94,
                  xmax = 3.06),
              fill = "gray30") +
    theme_bw() +
    labs(title = "Average age of Star Wars characters for women, men, and droids at the Battle of Yavin",
           y = "Age (years)",
           x = "Gender",
           legend = "Gender",
           caption = "Data from https://swapi.co.")
```

*** 

#### Intended Message

At its most basic, the plot to the left was intended to illustrate how the age of characters in the Starwars universe differ by gender. However, other than wanting to convey the average difference in ages among genders in the Star Wars universe, I think it is important to consider that the mean age of the female characters is so young compared to that of the male characters. It seems the recent movies have taken both incidental (e.g., Carrier Fisher) and deliberate (e.g., Laura Dern) steps to include older women. Star Wars would certainly benefit from being more inclusive when it comes to casting. 

#### Intended Audience

The intended audience for this visualization are fans of Star Wars and the general public.

#### Description of Version One

I refer to this first attempt as the LEGO&reg; Star Wars version of this plot, owing mostly to the simplistic design of the lightsaber[^1] hilt. Despite its evidence simplicitly, this code is likely the most complex of the lightsaber versions; all of the code for creating the hilt was included with the main `ggplot2` coding chunk and I rewrote the code for each of the hilts. I also created the aura in the main `ggplot2` coding chunk by call `geom_col` six times and decreasing the alpha and increasing the width on each additional call. 

[^1]: In accordance with the spelling choices of `ggplot2`, this should actually be "lightsabre".


### Version Two

```{r people_viz_v2}
people %>%
  filter(gender == "male" | gender == "female") %>%
  group_by(gender) %>%
  summarise(m_age = mean(birth_year, na.rm = TRUE)) %>%
  mutate(gender = str_to_title(gender),
         gender = as.factor(gender)) %>%
  ggplot(aes(x = gender, y = m_age, fill = gender)) +
    geom_saberblade() +
    scale_fill_manual(values = c("#0FFF00", "#FF0000")) +
    scale_color_manual(values = c("#0FFF00", "#FF0000")) +
    geom_saberhilt(column = 1) +
    geom_saberhilt(column = 2) +
    theme_bw() +
    labs(title = "Average age and gender",
           y = "Age (years)",
           x = "Gender",
           legend = "Gender",
           caption = "Data from https://swapi.co.") +
    theme(legend.position = "none", panel.grid.major.x =                   element_blank())
```

*** 

#### Description of Version Two

For the second verion, I removed all the code forcreating the hilts the blades and saved them in separate functions that are sourced at the beginning of the document. These functions are essentially just lists of geom_*s. The `geom_saberhilt` function takes one argument (i.e., `column`), which  simply tells the function which column to make the hilt for and adjusts its position accordingly. In total, each hilt is made up of eight separate rectangles. I added a black color (i.e., outline) to make the separate component of the hilt pop. 

I also dropped the droid lightsaber from this plot. It seemed to be distracting from the intended message of the plot. 

Following the advice of Daniel Anderson (AKA [datalorax](https://github.com/datalorax)) I dropped the legend, as it was completely redundant with the x-axis of the plot. 

Finally, I added the ends of the blades using geom_point. As is clear from the plot, there are some size problems in comparing the end of the blades to the blade themselves. This primarly stems from the width of `geom_col` being relative to the size of the plot and `geom_point` being absolute.

### Version Three

```{r people_viz_v3}
# people plot
people %>%
  filter(gender == "male" | gender == "female") %>%
  group_by(gender) %>%
  summarise(m_age   = mean(birth_year, na.rm = TRUE),
            m_age_r = round(m_age, 2),
            m_age_r = paste(m_age_r, "YEARS")) %>%
  mutate(gender = str_to_title(gender),
         gender = as.factor(gender)) %>%
  ggplot(aes(x = gender, y = m_age, fill = gender)) +
    geom_saberblade() +
    scale_fill_manual(values = c("#0FFF00", "#FF0000")) +
    scale_colour_manual(values = c("#0FFF00", "#FF0000")) +
    geom_saberhilt(column = 1) +
    geom_saberhilt(column = 2) +
    geom_text(aes(label = m_age_r, color = gender), 
              size = 6, 
              position = position_nudge(x = -.09, y = -8)) +
    labs(title = "Average age and gender",
           y = "Age (years)",
           x = "Gender",
           legend = "Gender",
           caption = "Data from https://swapi.co.") +
    my_theme() +
    coord_flip()
```

***

#### Description of Version Three

I like to think of this version as the [How to Draw A Horse](https://knowyourmeme.com/photos/572093-how-to-draw-an-owl) version, given its massive improvement over the previous plot. 

Also following the advice of [Daniel Anderson](https://github.com/datalorax) I `coord_flip`ed the plot, which drastically improved the look of the lightsabers. I assume the improvement is due to some innate preference towards landscape orientation over portrait orientation, but, in any case, it allows the plot to more neatly fit on a computer screen.

[Daniel](https://github.com/datalorax) also suggeted I add annotations, which I added in the form of the means provided slightly below the blades. To achieved this, I used `position_nudge(x = -.09, y = -8)` to move the `geom_text` labels away from the actual means of the two groups.

I also created a simple black and pink (specifically deeppink2) theme to a separate function script that I also sourced at the beginning of the document and added to this plot. In the theme script, I also bolded the title, the axes titles, the axis text, and the caption. I also customized the major grid lines and completely removed the minor gridliens. Finally, I automatically suppressed the legend using `legend.position = "none"`. I did customize the legend to be consistent with the rest of the theme in case I decided the include a legend, which I did in [visualization 3][The Planets].

### Version Four

```{r people_viz_v4}
# people plot
people %>%
  # filter for only females and males and drop the outlier (yoda)
  filter(gender == "female" | gender == "male",
         name   != "Yoda") %>%
  # group by gender
  group_by(gender) %>%
  # calculate mean age and rounded mean age for geom_text
  summarise(m_age   = mean(birth_year, na.rm = TRUE),
            m_age_r = round(m_age, 2),
            m_age_r = paste(m_age_r, "YEARS")) %>%
  # convert genders to title case and gender to a factor
  mutate(gender = str_to_title(gender),
         gender = as.factor(gender)) %>%
  # plot gender vs age and fill by gender
  ggplot(aes(x = gender, y = m_age, fill = gender)) +
    # add the lightsaber blades to the plot
    geom_saberblade() +
    # add the lightsaber hilts to the plot
    geom_saberhilt(column = 1) +
    geom_saberhilt(column = 2) +
    # set colour and fill values (i.e., red and green)
    scale_fill_manual(values   = c("#0FFF00", "#00f6ff")) +
    scale_colour_manual(values = c("#0FFF00", "#00f6ff")) +
    # add text with the mean ages to the plot
    geom_text(aes(label = m_age_r, color = gender), 
              size     = 6, 
              position = position_nudge(x = -.09, y = -6)) +
    # customize y-axis
    scale_y_continuous(breaks = c(0, 20, 40, 60)) +
    # add labels
    labs(title    = "Average Age of Characters by Gender",
         subtitle = "Excluding Yoda (for obvious reasons)",
         y        = "Age (years)",
         x        = "Gender",
         legend   = "Gender",
         caption  = "Data from https://swapi.co.") +
    # customize using my theme
    my_theme() +
    # flip the coordinates
    coord_flip()
```

*** 

#### Description of Version 4

In the (current) final plot of the peoples ages, I followed the advice of [Jon Rochelle](https://github.com/jrochel2) and [Maria Schweer-Collins](https://github.com/schweercollins) to change the color of the lightsaber for males from red, as it would seem to imply that this was representing the average age of male characters who had also succumbed to the Dark Side. I was initially weary of using blue to represent males as I usually try to avoid using the conventional colors to represent men and women. In this case, I think the use of blue is excusable. 

Also as noted by [Andrew Edelblum](https://github.com/AndrewEdelblum), Yoda is a major outlier at 896 years old. The only character who would seem to be even close to Yoda was Jabba Desilijic Tiure at 600 years old, but Jabba is hermaphroditic and, therefore, dropped from the plot. In order to address Yoda's age, I simply dropped him from the plot and noted in the plot's subtitle that he was excluded. I did consider including a point to indicate where he was on the plot, but that would require an x-axis that spanned to around 900, which would seem to obscure the intended message of the plot.

[Andrew](https://github.com/AndrewEdelblum) and [Maria](https://github.com/schweercollins) also suggested that the title should inlude "age *by* gender" rather than "age *and* gender". They were completely correct, and I make the corresponding changes. 

Finally, I switched to using title case for the title and adjusted the x-axis limits using `scale_y_continuous` (scale_*y* since the coordinates were flipped).

# The Starships {.storyboard data-icon="fa-space-shuttle"}

### Version One

```{r starships_viz_v1}
# starships plot
starships %>%
  group_by(starship_class) %>%
  filter(!is.na(length),
         n() > 1) %>%
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  filter(!is.na(len_sd)) %>%
  mutate(len_se = len_sd / sqrt(len_n)) %>%
    ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
      geom_errorbar(aes(ymin = len_m - (len_se * 1.96), ymax = len_m + (len_se * 1.96)), 
                    width = .5) +
      geom_point(size = 5) +
      geom_point(size = 3, shape = 13, color = "grey80") +
      coord_flip() +
      theme_bw() +
      labs(title = "Average length of starship by ship class",
           y = "Average Length (meters)",
           x = "Ship class",
           caption = "Data from https://swapi.co.")
```

*** 

#### Intended Message

Overall, the plot is aimed as illustrating how starships from Star Wars differ in size. Specifically, Yachts are the largest ships with assault starfighters being slightly larger than basic starfighters. Yachts also have the most variable sizes among all of the starships. 

#### Intended Audience

Although the audience for this plot are generally the same as the previous plot (i.e., the general public and fans of Star Wars), I believe this one is skewed far more towards Star Wars fans and also those who are knowledgable enough about statistics to be able to interpret the error bar. 

#### Description of Version One

Points and standard error bars have always looked like Tie Fighters to me, so I decided I would try to plot the length of a starship by starship class (i.e., Starfighters, Assault Starfighters, and Yachts). I excluded any class that only had one ship type in the dataset (e.g,, Star Destroyers). To achieve the look I was going for, I plotted the error bar using `geom_errorbar` and then plotted a black `geom_point` for the ships hull and a grey `geom_point` of shape 13 for the ships window. 

### Version Two
```{r starships_viz_v2}
# create stars data
stars_data <- tibble(x     = sample(seq(from = 0,   to = 4,  by = .0001), 500),
                     y     = sample(seq(from = 0,   to = 80, by = .0001), 500),
                     trans = sample(seq(from = .1, to = .9,   by = .0001), 500))

# starships plot
starships %>%
  group_by(starship_class) %>%
  filter(!is.na(length),
         n() > 1) %>%
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  filter(!is.na(len_sd)) %>%
  mutate(len_se = len_sd / sqrt(len_n)) %>%
    ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
      geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                        ymax = len_m + (len_se * qnorm(.975))), 
                    width = .5, color = "grey30", lwd = 1.2) +
      geom_point(size = 5, color = "grey30") +
      geom_point(size = 2, color = "grey10") +
      geom_point(size = 3, shape = 13, color = "grey60") +
      geom_point(data = stars_data, aes(x = x, y = y, alpha = trans), 
                 color = "white",
                 size = .001) +
      coord_flip() +
      theme_bw() +
      theme(panel.background = element_rect(fill = "#000000")) +
      labs(title = "Average length of starship by ship class",
           y = "Average Length in Meters",
           x = "Ship class",
           caption = "Data from https://swapi.co.") + 
      scale_y_continuous(limits = c(0,80), expand = expand_scale(mult = c(0, 0)))
```

***
#### Description of Version Two

For the second version, I changed the ships wings and the hull to a dark gray to more accurately reflect the look of a tie fighter. I also added a black `geom_point` between the window frame and the hull points to add the windows.

In this stage, I also created random data to represent stars in the plot. To do this, I randomly `sample`d (without replacement) 500 values between the x-axis limits of 0 and 4, 500 values between the y-axis limits of 0 and 80, and 500 values between alpha values of .1 and .9. I simply plotted these in white using `geom_point`.

To show the stars in this version, I retroactively added in a black background. The original plot had used the `new_retro` theme from the [vapoRwave](https://github.com/moldach/vapoRwave) package by Matthew Oldach ([moldach](https://github.com/moldach)). Unfortunately, that theme used fonts that drastically limited reproducability.

### Version Three
```{r starships_viz_v3}
# generate random x, y, and transparency data to use for plotting stars
stars_data <- tibble(x     = sample(seq(from =  0, to =  4, by = .0001), 500),
                     y     = sample(seq(from =  0, to = 80, by = .0001), 500),
                     trans = sample(seq(from = .1, to = .9, by = .0001), 500))
# starships plot
starships %>%
  # group by starship_class
  group_by(starship_class) %>%
  # drop rows that have an NA for length 
  filter(!is.na(length)) %>%
  # calculate mean length and standard deviation, as well as number of ships in 
  # that class
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  # retain classes that have more than one ship
  filter(len_n > 1) %>%
  # convert starship_class to title case and wrap multi-word levels
  mutate(starship_class = str_to_title(starship_class),
         starship_class = gsub(" ", " \n", starship_class)) %>%
  # calculate standard error
  mutate(len_se = len_sd / sqrt(len_n)) %>%
    # plot starship class v starship length
    ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
      # add error bars
      geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                        ymax = len_m + (len_se * qnorm(.975))), 
                    width = .5, colour = "grey30", lwd = 1.2) +
      # add stars 
      geom_point(data = stars_data, aes(x = x, y = y, alpha = trans), 
                 colour = "white",
                 size = .001) +
      # plot ship body points
      geom_point(size = 6, colour = "grey30") +
      geom_point(size = 3, colour = "grey10") +
      geom_point(size = 4, shape = 13, colour = "grey60") +
      # flip the coordinates
      coord_flip() +
      # add labels
      labs(title   = "Average length of starship by ship class",
           y       = "Average Length in Meters",
           x       = "Class",
           caption = "Data from https://swapi.co.") + 
      # set y-axis limits and do not show value beyond limits of y-axis
      scale_y_continuous(limits = c(0,80), 
                         expand = expand_scale(mult = c(0, 0))) + 
      # customize using my theme
      my_theme()
```

***

#### Description of Version Three

Version 3 involved mostly minor appearence changes. I added `my_theme` to make the theme consistent with my other visualizations and made the size of the ships' bodies larger to be more consistent with an actual (fictional) tie fighter. I also added a `\n` between "assault" and "starfighter" in the y-axis labels so that "Assault Starfighter" did not take up substantially more space than the other labels.

### Version Four

```{r starships_viz_v4}
# generate random x, y, and transparency data to use for plotting stars
stars_data <- tibble(x     = sample(seq(from =  0, to =  4, by = .0001), 500),
                     y     = sample(seq(from =  0, to = 80, by = .0001), 500),
                     trans = sample(seq(from = .1, to = .9, by = .0001), 500))

# starships plot
starships %>%
  # group by starship_class
  group_by(starship_class) %>%
  # drop rows that have an NA for length 
  filter(!is.na(length)) %>%
  # calculate mean length and standard deviation, as well as number of ships in 
  # that class
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  # retain classes that have more than one ship
  filter(len_n > 1) %>%
  # convert starship_class to title case and wrap multi-word levels
  mutate(starship_class = str_to_title(starship_class),
         starship_class = gsub(" ", " \n", starship_class)) %>%
  # calculate standard error
  mutate(len_se = len_sd / sqrt(len_n)) %>%
  # plot starship class v starship length
  ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
    # add error bars
    geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                      ymax = len_m + (len_se * qnorm(.975))), 
                  width = .5, colour = "grey70", lwd = 1.25) +
    geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                      ymax = len_m + (len_se * qnorm(.975))), 
                  width = .5, colour = "grey30", lwd = 1) +
    # add stars 
    geom_point(data = stars_data, aes(x = x, y = y, alpha = trans), 
               colour = "white",
               size = .001) +
    # plot ship body points
    geom_point(size = 6.70, colour = "grey70") +
    geom_point(size = 6.40, colour = "grey30") +
    geom_point(size = 4.40, colour = "grey10") +
    geom_point(size = 3.40, colour = "grey60", shape = 8) +
    geom_point(size = 4.40, colour = "grey60", shape = 1) +
    geom_point(size = 2.00, colour = "grey60") +
    geom_point(size = 1.50, colour = "grey10") +
    # flip the coordinates
    coord_flip() +
    # add labels
    labs(title    = "Average Length of Starship by Ship Class",
         subtitle = "Mean length indicated by ship body position\nConfidence interval (95%) indicated by wing span",
         y        = "Average Length in Meters",
         x        = "Class",
         caption  = "Data from https://swapi.co.") + 
    # set y-axis limits and do not show value beyond limits of y-axis
    scale_y_continuous(limits = c(0,80), 
                       expand = expand_scale(mult = c(0, 0))) + 
    # customize using my theme
    my_theme() +
    theme(plot.margin  = unit(c(1, 1, 1, 1), "cm"),
          axis.title.y = element_text(vjust = 5))
```

*** 

#### Description of Version Four

In this version of the starship plot, I completely reworked the body of the starship to more accurately reflect the look of a tie fighter. I did this by adding three additional `geom_point` layers. 

Following [Jon's](https://github.com/jrochel2) advice, I also added a thin layer of light gray around the ships body to make the fighters pop from the starry background.

I did consider dropping the "class" y-axis title, because it seemed to intuitive to me, but then I realized it might not be as clear to others. Instead, I shifted the y-axis title away from the y-axis labels using `axis.title.y = element_text(vjust = 5)` so it didn't look as cramped. I also increased the plot magin on the right so the text wasn't right up against the plot border. 

Following [Maria](https://github.com/schweercollins)'s advice, I also attempted to plot the mean and standard error of each ship as text on the plot, but it was hard to find an appropriate space to put them. One would imagine immediately underneath the ships would be good, but given the difference width of the starship wings it leaves a large gap for the large ship. Instead I added subtitles that descrirbes what the starships represent. 


# The Planets {.storyboard data-icon="fa-globe-asia"}

### Version One

```{r planets_viz_v1, warning = FALSE}
# planets plot
planets %>%
  filter(area < mean(area, na.rm = TRUE) + (sd(area, na.rm = TRUE) * 3)) %>%
  ggplot(aes(x = au, y = surface_water, size = area)) +
    geom_point(alpha = .8, color = "yellow") +
    geom_smooth(method = "lm", se = FALSE, color = "yellow") +
    scale_color_gradient(high = "#0E0584", low = "#086703", na.value = "#AB8703") +
    theme(panel.background = element_rect(fill = "black"),
          panel.grid.major = element_line(size = .10),
          panel.grid.minor = element_line(size = .05)) +
    scale_y_continuous(labels = scales::percent) +
    xlim(.5,1.5) +
    labs(title = "Distance from the sun and amount of surface water",
         y = "Amount of surface water (%)",
         x = "Distance from star (Astronomical Units)",
         size = "Size",
         caption = "Data from https://swapi.co")

```

*** 

#### Intended Message

In the original version of this plot, I intended to illustrate that as a planet gets further from its star the amount of surface water decreases. This did seem to be the case, but I became more interested in the size of planets, orbital periods, and the distance of planets from their stars. In the end, the intent of the plot became illustrating that planets farther from the sun are both larger and orbit slower (and this holds in the Star Wars universe. )

#### Intended Audience

Again, those interested in Star Wars would likely enjoy this plot; some general background in astronomy would also help interpretation. 

#### Description of Version One

The first version of this plot used the Star Wars colors (black and yellow) to show the relationship between the amount of water on a planey and the distance of those units from the star. This relationship was illustrated using `geom_smooth` with the `method` set to `lm` and `geom_point`. Size was also mapped to the radii of the planets. It was simple plot. 

### Version Two

```{r planets_viz_v2, warning = FALSE}
# planets plot
planets %>%
  # select only variables of interest
  select(name, au, radius, solar_system) %>%
  # drop planets that do not have (1) a name, (2) a distance from the sun (i.e.
  # an AU), (3) an AU less than 2, and (4) a radius greater than 0.
  filter(!is.na(name),
         !is.na(au),
         # au < 2,
         radius       != 0.00,
         solar_system == FALSE) %>%
  # create a new variable indicating whether a planet was in the original 
  # trilogy
  mutate(orig_tril = case_when(name == "Alderaan" |
                               name == "Tatooine" |
                               name == "Yavin"    |
                               name == "Yavin 4"  ~ "new_hope",
                               name == "Bespin"   |
                               name == "Dagobah"  |                                 
                               name == "Hoth"     ~ "empire_strikes",                                
                               name == "Endor"    ~ "return_jedi",
                               TRUE ~ NA_character_)) %>%
  # sort the data by their distance from the sun
  arrange(au) %>%
  # add a column that arbitrarily assigns the planet a degree
  mutate(degree = seq(from = 1, to = 360, length.out = n())) %>%
  # plot the planets distance from the sun against their arbitrary degree
  ggplot(aes(x = degree, y = au)) +
    # add labels indicating y-axis units and add star and earth
    geom_text(aes(x =   0, y = 0, label = "STAR"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = 270, y = 2, label = "2 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = 270, y = 4, label = "4 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = 270, y = 6, label = "6 AU"), 
              color = "deeppink3", 
              size  = 7) +
    # add solar system planets
    geom_text(aes(x = 0, y = 1.00, label =   "EARTH"), 
      color = "deeppink3", 
      size  = 5) +
    geom_text(aes(x = 0, y = 1.52, label =    "MARS"), 
      color = "deeppink3", 
      size  = 5) +
    geom_text(aes(x = 0, y = 5.20, label = "JUPITER"), 
      color = "deeppink3", 
      size  = 5) +
    # add planet points; map size of the point to planet radius
    geom_point(aes(size = radius), alpha = .6, color = "#00ddff") +
    # make the coordinate polar
    coord_polar(theta = "x") +
    # set the limit of size values
    scale_size_continuous(range = c(.5, 10)) +
    # drop x-axis grid marks and breaks
    scale_x_continuous(breaks = NULL) +
    # set 2-axis limit
    scale_y_continuous(limits = c(0,7)) +
    # add labels
    labs(title    = "Distance of Star War's Planets from their Host Stars",
         subtitle = "in Astronomical Units (AU)", 
         caption  = "Data from https://swapi.co.") + 
    # customize using my theme
    my_theme() +
    # drop axis text and axis titles and center title, subtitle, and caption
    theme(plot.title    = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          plot.caption  = element_text(hjust = 0.5),
          axis.text     = element_blank(),
          axis.title    = element_blank(),
          plot.margin   = unit(c(1, 2, 1, 2), "cm")) +
    # add text identifying only those planetss from the original trilogy
    geom_label_repel(data = . %>% filter(!is.na(orig_tril)), aes(label = name),
                     color              = "#00ddff",
                     fill               =        NA,
                     size               =         8,
                     min.segment.length =         0,
                     nudge_y            =       2.1)
```

*** 

#### Description of Version Two

For the second plot, I dropped the interest in the amount of surface water the planet had and instead used `coord_polar` to see a top down version of a star system, with the planets arbitrarily arranged around their host star. As can be gleened from the plot, it does seem that large planets (in this case, Bespin) are farther from their host stars.

I also added my theme to this plot to make it consistent and used ggrepel to repel text labels for the planets from the orginal series. 

### Version Three

```{r planets_viz_v3, warning = FALSE}
# create function for calculating x axis locations during the time it takes
# bespin to make one rotation. The slices have to be numerous to obscure the
# geom_points jumping back at the end of the year
orbit_slice <- function(planet = NULL) {
  temp <- planets$orbital_period[which(planets$name == planet)]
  rep(seq(from = 0, to = 5110, length.out = (511*(temp/5110))), 
      length.out = 511)
}
# calculate locations on the x-axis for each planets during the time it takes
# bespin to make one rotation. 
orbital_degrees <- tibble(
  "Alderaan"   = orbit_slice("Alderaan"),
  "Hoth"       = orbit_slice("Hoth"),
  "Dagobah"    = orbit_slice("Dagobah"),
  "Bespin"     = orbit_slice("Bespin"),
  "Endor"      = orbit_slice("Endor"),
  "Tatooine"   = orbit_slice("Tatooine"),
  "Mercury"    = orbit_slice("Mercury"),
  "Venus"      = orbit_slice("Venus"),
  "Earth"      = orbit_slice("Earth"),
  "Mars"       = orbit_slice("Mars"),
  "Jupiter"    = orbit_slice("Jupiter"),
  "days_count" = 1:511
)
# gather days into a column and the planet names into another column
orbital_degrees %<>%
  gather(key = "name", value = "days", -days_count)
# planets plot
plot3 <- planets %>%
  # select only variables of interest
  select(name, au, radius, orbital_period, orig_tril, solar_system) %>%
  # drop planets that do not have (1) a name, (2) a distance from the sun (i.e.
  # an AU), (3) an AU less than 2, and (4) a radius greater than 0.
  filter(!is.na(name),
         !is.na(au),
         !is.na(orbital_period),
         !is.na(orig_tril) | solar_system == TRUE,
         # au < 2,
         radius != 0.00) %>%
  left_join(orbital_degrees, by = "name") %>%
  # plot the planets distance from the sun against their arbitrary degree
  ggplot(aes(x = days, y = au, color = solar_system)) +
    # add labels indicating y-axis units and add star and earth
    geom_text(aes(x =   0, y = 0, label = "STAR"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = max(days) * 3/4, y = 2, label = "2 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = max(days) * 3/4, y = 4, label = "4 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = max(days) * 3/4, y = 6, label = "6 AU"), 
              color = "deeppink3", 
              size  = 7) +
    # add planet points; map size of the point to planet radius
    geom_point(aes(size = radius), alpha = .6) +
    # add planet text
    geom_text(aes(label = name), 
              position  = position_nudge(y = 1.1), 
              alpha     = .7) +
    # make the coordinate polar
    coord_polar(theta = "x") +
    # add transsition following days
    transition_time(days_count) +
    # set the limit of size values
    scale_size_continuous(range = c(.5, 10)) +
    # drop x-axis grid marks and breaks
    scale_x_continuous(breaks = NULL) +
    # set 2-axis limit
    scale_y_continuous(limits = c(0,7)) +
    # set the colours
    scale_colour_manual(values = c("#02fff6", "#ff5d00")) +
    # add labels
    labs(title    = "Distance of Star War's Planets from their Host Stars",
         subtitle = "Day: {(frame_time*10)}", 
         caption  = "Data from https://swapi.co.") + 
    # customize using my theme
    my_theme() +
    # drop axis text and axis titles and center title, subtitle, and caption
    theme(plot.title    = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          plot.caption  = element_text(hjust = 0.5),
          axis.text     = element_blank(),
          axis.title    = element_blank(),
          plot.margin   = unit(c(1, 2, 1, 2), "cm")) #+
    #geom_label_repel(data = . %>% filter(!is.na(orig_tril)), aes(label = name),
    #                 color              = "#00ddff",
    #                 fill               =        NA,
    #                 size               =         8,
    #                 min.segment.length =         0,
    #                 nudge_y            =       2.1)
animate(plot3, 
        duration = 30,
        fps      = 5)
```

*** 

#### Description of Version Three

Although not interactive (as per [Andrew](https://github.com/AndrewEdelblum)'s) suggetiong, I animated the plot to add in another dimension of information. Namely, we can now see the orbital period of the planets. I also added the solar system plaents rather than jusst having them as labels on the plot to allow for easier comparison.

In order to have planetss continue rotating once they had completed their rotation, for example isntead of endor dissapearing from the plot after 402 days, I made a function called `orbital_slice` to generate the position of each planet at 511 time points during Bespin's 5110 day orbit. 

I also followed [Maria](https://github.com/schweercollins)'s advice and droped all the planets that are not in the original trilogy. 

### Version Four

```{r planets_viz_v4, fig.height = 12, warning = FALSE}
# create function for calculating x axis locations during the time it takes
# bespin to make one rotation. There has to be enough slices to obscure the
# geom_points jumping back at the end of Bespin's year
orbit_slice <- function(planet = NULL) {
  # grab orbital period of planet of interest
  temp <- planets$orbital_period[which(planets$name == planet)]
  # calculate 511 x-axis point for that planet throughout Bespin' year
  rep(seq(from         = 0, 
            to         = 5110, 
            length.out = (5110 * (temp / 5110))),
      length.out = 5110)
}

# calculate locations on the x-axis for each planets during the time it takes
# bespin to make one rotation. 
orbital_degrees <- tibble(
  "Alderaan"   = orbit_slice("Alderaan"),
  "Hoth"       = orbit_slice("Hoth"),
  "Dagobah"    = orbit_slice("Dagobah"),
  "Bespin"     = orbit_slice("Bespin"),
  "Endor"      = orbit_slice("Endor"),
  "Tatooine"   = orbit_slice("Tatooine"),
  "Mercury"    = orbit_slice("Mercury"),
  "Venus"      = orbit_slice("Venus"),
  "Earth"      = orbit_slice("Earth"),
  "Mars"       = orbit_slice("Mars"),
  "Jupiter"    = orbit_slice("Jupiter"),
  "days_count" = 1:5110
)

# gather days into a column and the planet names into another column
orbital_degrees %<>%
  gather(key = "name", value = "days", -days_count)

# planets plot
planets_plot <- planets %>%
  # select only variables of interest
  select(name, au, radius, orbital_period, orig_tril, solar_system) %>%
  # drop planets that do not have (1) a name, (2) a distance from the sun (i.e.
  # an AU), (3) an AU less than 2, and (4) a radius greater than 0.
  filter(!is.na(name),
         !is.na(au),
         !is.na(orbital_period),
         !is.na(orig_tril) | solar_system == TRUE,
         # au < 2,
         radius != 0.00) %>%
  left_join(orbital_degrees, by = "name") %>%
  #drop mercury and alderaan
  filter(name != "Mercury", # mercury for orbiting too quickly
         name != "Alderaan") %>% # alderaan for esssentially being earth 2.0
  # plot the planets distance from the sun against their arbitrary degree
  ggplot(aes(x = days, y = au, color = solar_system)) +
    # add labels indicating y-axis units and add star and earth
    geom_text(aes(x =   0,          y = 0, label = "STAR"), 
              color = "deeppink3", 
              size  = 5) +
    geom_text(aes(x = 5110 * 3 / 4, y = 2, label = "2 AU"), 
              color = "deeppink3", 
              size  = 5) +
    geom_text(aes(x = 5110 * 3 / 4, y = 4, label = "4 AU"), 
              color = "deeppink3", 
              size  = 5) +
    geom_text(aes(x = 5110 * 3 / 4, y = 6, label = "6 AU"), 
              color = "deeppink3", 
              size  = 5) +
    # add label for describing 1 AU
    annotate(geom  =                   "label", 
             x     =             5110 * 1 / 2,
             y     =                        7,
             label = "1 AU = ~150,000,000 km", 
             color =              "deeppink2",
             fill  =                  "black",
             size  =                        5) +
    # add planet points; map size of the point to planet radius
    geom_point(aes(size = radius), alpha = .6) +
    # add planet text; also suppress its legend
    geom_text(aes(label   = name), 
              position    = position_nudge(y = 1.1), 
              alpha       = .7,
              size        =  5,
              show.legend = FALSE) +
    # make the coordinate polar
    coord_polar(theta = "x") +
    # add transition according to days
    transition_manual(days_count) +
    # set the limit of size values
    scale_size_continuous(range = c(.5, 10)) +
    # drop x-axis grid marks and breaks
    scale_x_continuous(breaks = NULL) +
    # set 2-axis limit
    scale_y_continuous(limits = c(0, 7)) +
    # set the colours
    scale_colour_manual(name   = "Star System",
                        values = c("#02fff6", "#ff7b00"),
                        labels = c("Solar System", "Star Wars")) +
    # add labels
    labs(title    = "Distance from Host Star and Orbital Period",
         subtitle =                         "Days: {current_frame}", 
         caption  =                "Data from https://swapi.co.") +
    # customize using my theme
    my_theme() +
    # drop axis text and axis titles and center title, subtitle, and caption
    theme(plot.title      = element_text(hjust = 0.5),
          plot.subtitle   = element_text(hjust = 0.5),
          plot.caption    = element_text(hjust = 0.5),
          axis.text       = element_blank(),
          axis.title      = element_blank(),
          plot.margin     = unit(c(1, 5, 1, 7), "cm"),
          legend.position = "right") +
    # drop radius legend and change the size of the legend points
    guides(size = FALSE,
           colour = guide_legend(override.aes = list(size  = 5,
                                                     alpha = 1)))

# animate plot with a duration of 55 and a fps of  48
animate(planets_plot, 
        nframes = 24 * 55,
        fps     = 24)

``` 

*** 

#### Description of Version Four

A problem with using `transition_time` from the `gganimate` package with repating orbit data is that at the end of each planet's orbit, it attempts to go from its current place on the x-axis at 5110 days back to zero. At slow enough speeds you can see at the end of each orbit the planet actually has to back track all the  way around the graph. I attempted to insert and NA in the data, so that it would briefly dissapear, but this presented two problems. First, I needed incredibly high number of slices so that it did not dissapear for two long, it was causing flickering in the points. 

To combat this, I switched from using `transition_time` to using `transition_manual`. I still had to use a large number of slices. but the effect was far smoother and no flickering occured. A side benefit, which I found really rewarding, is that now the days counts up by 1s instead of 10s. I had used 10s in the previous plot becasue I wanted to deal with less data and animating the tweens was resource intensive.

I also added a translation from AUs to kms. 
