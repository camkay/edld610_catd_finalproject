---
title: "Visualizing Star Wars"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    css: resources/css/custom.css
    logo: resources/images/jedi_logo.png
    favicon: resources/images/jedi_fav.png
---

```{r setup, include = FALSE}
# load necessary packages (if you do not have them, you will need to install them first)
library(flexdashboard) # for creating the flex dashboard. 
library(DT) # for creating table html widgets
library(tidyverse) # for dataframe manipulation and plotting
library(magrittr) # for updating an object that is piped into a function (using `%<>%`)
library(here) # for finding the project folder
library(repurrrsive) # contains the star wars datasets
library(rlist) # for binding all lit elements by column (using `list.cbind`)
library(ggrepel) # for adding geom_text labels that do not overlap
library(gganimate) # for animating the plot

# add gravitational constant (i.e., 6.67408 * 10^-11)
grav_constant <- 6.67408 * (10 ^ -11)

# load bespoke functions from the functions folder
source(here("resources/functions/my_theme.R")) # load my_theme
source(here("resources/functions/geom_saberhilt.R")) # load the function for creating the hilts of lightsabers
source(here("resources/functions/geom_saberblade.R")) # load the function for creating the blades of lightsabers

# set figure output dimensions
knitr::opts_chunk$set(fig.width  = 12, 
                      fig.height = 8)

```

# The Data {.storyboard data-icon="fa-database"}

### Introducing the Data

```{r introduction}
knitr::include_graphics(here("resources/images/swapi.png"))
```

***
Welcome! 

This portfolio shows the development of three different visualizations 
of the Star Wars universe. The [first visualization][The People] shows the average age of characters in the universe bifurcated by gender. The [second visualization][The Starships] demonstrates how starship classes differ in terms of length. The [third visualization][The Planets] illustrates the distance of Star War's planets from their host stars and animates their orbital periods. Planets from our solar system are included for easy comparison.

All of the data for the visualizations are from [Jenny Bryan](https://github.com/jennybc)'s  [repurrrsive](https://github.com/jennybc/repurrrsive) package. The [repurrrsive](https://github.com/jennybc/repurrrsive) package includes various datasets to assist in the teaching of R. The Star Wars dataset is originally from [SWAPI](https://swapi.co) (i.e., the Star Wars API).

### The People Data

```{r load_people_data}
# load and format data
people <- data.frame(t(list.cbind(sw_people))) %>%
  # convert the star wars people dataframe to a tibble
  as_tibble() %>%
  # select only the columns between name and gender (inclusive)
  select(name:gender) %>%
  # mutates columns that are lists to non-lists
  mutate_if(is.list, ~(unlist(.))) %>%
  # mutate all columns and replaces the text "unknown" with "NA"
  mutate_all(~(na_if(., "unknown"))) %>%
  # converts height and mass to numeric variables
  mutate_at(vars(height, mass), ~(as.numeric(.))) %>%
  # extracts birth year and converts it to numeric; replace "n/a" values with 
  # droid for hair_color and gender
  mutate(birth_year = parse_number(as.character(birth_year)),
         hair_color = if_else(gender == "n/a", "droid", hair_color),
         gender     = if_else(gender == "n/a", "droid", gender))

# embed the data
datatable(people)
```

*** 

In order to get the people data into the correct format for our visualization, I first made a `tibble` of the data from [repurrrsive](https://github.com/jennybc/repurrrsive)'s `sw_people` dataset. I selected only those columns of interest and unlisted the columns (all of the data in [repurrrsive](https://github.com/jennybc/repurrrsive) is, as the name would suggest, stored in recursive lists). I then converted the variables to the correct variable types and replaced "n/a" with more meaningful values. I also used `parse_number` to extract the characters' ages from their birth year. Although the number actually refers to how many years before or after the Battle of Yavin a character was born, all characters that had values for `birth_year` were born before the Battle of Yavin. Therefore, the result of `parse_number` provided all of the characters' ages at the Battle of Yavin.

### The Starships Data

```{r load_starships_data, warning = FALSE}
# load and format data
starships <- data.frame(t(list.cbind(sw_starships))) %>%
  # convert the star ways starship dataset to a tibble
  as_tibble() %>%
  # clean column names
  janitor::clean_names() %>%
  # select only those columns between name and starship (inclusive)
  select(name:starship_class) %>%
  # mutate columns that are lists to non-lists
  mutate_if(is.list, ~(unlist(.))) %>%
  # mutate all columns, replacing "unknown" with "NA"  
  mutate_all(~(na_if(., "unknown"))) %>%
  # convert numeric columns to numerics
  mutate_at(vars(cost_in_credits,
                 length,
                 crew,
                 passengers,
                 cargo_capacity,
                 hyperdrive_rating,
                 mglt), ~(as.numeric(.))) %>%
  # extract the max_atmosphering_speed and convert starship_class to a lowercase
  # factor
  mutate(max_atmosphering_speed = parse_number(max_atmosphering_speed),
         starship_class         = as.factor(tolower(starship_class))) %>%
  # seperate consumables into a value and unit (e.g., days, weeks, months, 
  # years)
  separate(consumables, c("con_n", "con_unit"), sep = " ") %>%
  # convert units to numeric values and multiply with the consumable value to 
  # provide the amount of consumable in the total number of days
  mutate(con_unit    = case_when(str_detect(con_unit,  "hour") ~  ".0417",
                                 str_detect(con_unit,   "day") ~      "1",
                                 str_detect(con_unit,  "week") ~      "7",
                                 str_detect(con_unit, "month") ~     "30",
                                 str_detect(con_unit,  "year") ~    "365"),
         consumables = as.numeric(con_n) * as.numeric(con_unit)) %>%
  # retain only the new consumables column (i.e., drop con_n and con_unit)
  select(-starts_with("con_"))

# embed the data
datatable(starships)
```

*** 

To get the data into the correct format for the starship visualization, I again created a `tibble` of the data from [repurrrsive](https://github.com/jennybc/repurrrsive)'s `sw_starships` dataset and unlisted the columns that were stored as lists. I converted all numeric variables to be numeric. Consumables (i.e., the amount of food and life-preserving resources the ship can hold) had a rather odd format: the variable had both a number and a unit (e.g., 1 month, 3 years, 1 week, 5 days). To address this, I used `separate` to first split the integer (e.g., 1, 3, 1, 5) from the unit of time (month, years, week, days). I then converted the unit to the number of days it represented using a combination of `case_when` and `str_detect`. I used `str_detect` to account for singulars and plurals in the units of time (e.g., 1 day vs 15 days). I then multiplied the integer and the unit of time together to create the number of days the starship had consumables for. 

### The Planets Data

```{r load_planets_data, warning = FALSE}
# load and format data
planets <- data.frame(t(list.cbind(sw_planets))) %>%
  # convert star wars planets dataset to a tibble
  as.tibble() %>%
  # retain only columns between name and population (inclusive)
  select(name:population) %>%
  # mutate columns that are lists to non-lists
  mutate_if(is.list, ~(unlist(.))) %>%
  # mutate all columns, replacing "unknown" with "NA"  
  mutate_all(~(na_if(., "unknown"))) %>%
  # convert numeric columns to type numeric
  mutate_at(vars(rotation_period,
                 orbital_period,
                 diameter,
                 surface_water,
                 population),
            ~(as.numeric(.))) %>%
  # calculate values of interest
  mutate(
         # make surface water a proportion
         surface_water   = surface_water / 100,
         # calculate population in millions
         population_mils = population / 1000000,
         # calculate a planet's distance from the sun (Kepler's 3rd law)
         au              = (((orbital_period / 365) ^ 2) ^ (1/3)),
         # convert gravity to a number
         gravity         = parse_number(as.character(gravity)),
         # calculate the force of gravity
         g               = gravity * 9.8, 
         # calculate radius
         radius          = diameter / 2, 
         # calculate planet mass (ish)
         mass            = (g * (radius^2)) / grav_constant,
         # calculate planet area
         area            = pi * (radius^2),
         # create column indicating whether the planet is in the solar system
         solar_system    = rep(FALSE, n()),
         # create a new variable indicating whether a planet was in the original 
         # trilogy
         orig_tril = case_when(name == "Alderaan" |
                               name == "Tatooine" |
                               name == "Yavin"    |
                               name == "Yavin 4"  ~ "new_hope",
                               name == "Bespin"   |
                               name == "Dagobah"  |                     
                               name == "Hoth"     ~ "empire_strikes",    
                               name == "Endor"    ~ "return_jedi",
                               TRUE ~ NA_character_))

# create dataset for planets in the solar system
sol_sys <- tibble(
  name           = c("Mercury", "Venus", "Earth", "Mars", "Jupiter"),
  orbital_period = c(       88,     225,     365,    687,      4330),
  au             = c(      .39,     .72,       1,   1.52,      5.20),
  solar_system   = c(     TRUE,    TRUE,    TRUE,   TRUE,      TRUE),
  radius         = c(   2439.5,    6052,    6378,   3396,     71492)
)

#combine the star war's planets and solar system data into one dataset
planets <- bind_rows(planets, sol_sys)

# embed the data
datatable(planets) 
```

*** 

Again, I converted [repurrrsive](https://github.com/jennybc/repurrrsive)'s `sw_planets` dataset to a `tibble`, unlisted the list columns, and converted the numeric variables to numeric variables. 

When I cleaned the variables, I wasn't exactly sure what variables I was going to use for my plot, so I ended up creating a lot of additional variables that I thought could be interesting to plot. Directly applicable to my final plot, I calculated the planets' distances from their stars using Kepler's Third Law (i.e., "The squares of the sidereal periods (of revolution) of the planets are directly proportional to the cubes of their mean distances from the Sun" - [EncyclopÃ¦dia Britannica](https://www.britannica.com/science/Keplers-laws-of-planetary-motion)). Essentially, the distance of a planet from its star is proportional to the length of its year. In this case, I used Astronomical Units (AU; ~150,000,000 km) to represent the distance from the star to the planet. Using astronomical units is helpful in this case because they are far more manageable and, since the distance from the Earth to the Sun is approximately 1 AU, they are far more interpretable. Although, if one is able to hold the thought of 1,636,025,600 football fields in their head, that would also be [a viable option](https://www.reddit.com/r/memes/comments/a7hnx7/daaaaaaaaamn_never_knew_that/).

I also added a column indicating whether the planet was featured in the original trilogy using data from [Wikipedia](https://en.wikipedia.org/wiki/List_of_Star_Wars_planets_and_moons). Finally, I used data from [NASA](https://nssdc.gsfc.nasa.gov/planetary/factsheet/) and [Ask an Astronomer](http://curious.astro.cornell.edu/about-us/56-our-solar-system/planets-and-dwarf-planets/general-questions/214-how-far-is-each-planet-from-earth-intermediate) to add the first five planets in the Solar System to the dataset, including their AUs, orbital periods, and their radii. 

# The People {.storyboard data-icon="fa-user-astronaut"}

### Version One

```{r people_viz_v1}
# people plot
people %>%
  filter(gender == "male" | gender == "female" | gender == "droid") %>%
  group_by(gender) %>%
  summarise(m_age = mean(birth_year, na.rm = TRUE)) %>%
  ggplot(aes(x = factor(gender), y = m_age, fill = factor(gender))) +
    geom_col(width = 0.10) +
    geom_col(width = 0.12, alpha = .6) +
    geom_col(width = 0.14, alpha = .4) +
    geom_col(width = 0.16, alpha = .2) +
    geom_col(width = 0.18, alpha = .1) +
    scale_fill_manual(values = c("#0FFF00", "#FF0000", "#000CFF")) +
    geom_rect(aes(ymin = -10, 
                  ymax = 0, 
                  xmin = .95,
                  xmax = 1.05),
              fill = "gray30") +
    geom_rect(aes(ymin = -10, 
                  ymax = 0, 
                  xmin = 1.95,
                  xmax = 2.05),
              fill = "gray30") +
    geom_rect(aes(ymin = -10, 
                  ymax = 0, 
                  xmin = 2.95,
                  xmax = 3.05),
              fill = "gray30") +
    geom_rect(aes(ymin = -5, 
                  ymax = -20, 
                  xmin = .94,
                  xmax = 1.06),
              fill = "gray30") +
    geom_rect(aes(ymin = -5, 
                  ymax = -20, 
                  xmin = 1.94,
                  xmax = 2.06),
              fill = "gray30") +
    geom_rect(aes(ymin = -5, 
                  ymax = -20, 
                  xmin = 2.94,
                  xmax = 3.06),
              fill = "gray30") +
    theme_bw() +
    labs(title = "Average age of Star Wars characters for women, men, and droids at the Battle of Yavin",
           y = "Age (years)",
           x = "Gender",
           legend = "Gender",
           caption = "Data from https://swapi.co.")
```

*** 

#### Intended Message

At its most basic, the plot to the left was intended to illustrate how the ages of characters in the Starwars universe differ by gender. Other than wanting to convey the average difference in ages among genders in the Star Wars universe, I think it is important to consider that the mean age of the female characters is so young compared to that of the male characters. It seems the recent movies have taken both incidental (e.g., Carrie Fisher) and deliberate (e.g., Laura Dern) steps to include older women. Star Wars would certainly benefit from being more inclusive when it comes to casting. 

#### Intended Audience

The intended audience for this visualization are fans of Star Wars and the general public. No advanced statistical knowledge would be required to interperet it. 

#### Description of Version One

I refer to this first attempt as the LEGO&reg; Star Wars version of this plot, owing mostly to the simplistic design of the lightsaber[^1] hilt. Despite its evident simplicitly, the code is likely the most complex of all of the versions of this plot. The code for creating the hilt was included in the plotting code (rather than simply calling a function) and I repeated the code to generate the hilt for each lightsaber. I also included the code to create the blade and blade aura in the main `ggplot` code chunk, requiring the inclusion of six separate `geom_col` layers with decreased alpha and increased width for each additional call. 

[^1]: Which, in the `ggplot2` universe, would be "lightsabre".


### Version Two

```{r people_viz_v2}
people %>%
  filter(gender == "male" | gender == "female") %>%
  group_by(gender) %>%
  summarise(m_age = mean(birth_year, na.rm = TRUE)) %>%
  mutate(gender = str_to_title(gender),
         gender = as.factor(gender)) %>%
  ggplot(aes(x = gender, y = m_age, fill = gender)) +
    geom_saberblade() +
    scale_fill_manual(values =  c("#0FFF00", "#FF0000")) +
    scale_color_manual(values = c("#0FFF00", "#FF0000")) +
    geom_saberhilt(column = 1) +
    geom_saberhilt(column = 2) +
    theme_bw() +
    labs(title     = "Average age and gender",
           y       = "Age (years)",
           x       = "Gender",
           legend  = "Gender",
           caption = "Data from https://swapi.co.") +
    theme(legend.position    = "none", 
          panel.grid.major.x = element_blank())
```

*** 

#### Description of Version Two

For the second version, I removed all the code for creating the hilts and the blades from the `ggplot` code chunk. Instead, I saved them in separate scripts that are sourced at the beginning of the `R Markdown` document used to deploy this dashboard. Each function is essentially just a `list` with multiple `geom_*`s inside of it. The `geom_saberhilt` function takes one argument (i.e., `column`), which simply tells the function which column to make the hilt for and adjusts its position accordingly. In total, each hilt is made up of eight separate rectangles. I added a black outline to make the separate component of the hilt pop. 

I also dropped the droid lightsaber from this plot. It seemed to be distracting from the intended message of the plot. 

Following the advice of [Daniel Anderson](http://www.datalorax.com) (AKA [datalorax](https://github.com/datalorax)), I dropped the legend, as it was completely redundant with the x-axis of the plot. 

For the second version, I also added the ends of the blades using geom_point. As is clear from the plot, there is a size discrepancy between the end of the blades and the blades themselves. This primarily stems from the width of `geom_col` being relative to the size of the plot and `geom_point` being absolute.

### Version Three

```{r people_viz_v3}
# people plot
people %>%
  filter(gender == "male" | gender == "female") %>%
  group_by(gender) %>%
  summarise(m_age   = mean(birth_year, na.rm = TRUE),
            m_age_r = round(m_age, 2),
            m_age_r = paste(m_age_r, "YEARS")) %>%
  mutate(gender = str_to_title(gender),
         gender = as.factor(gender)) %>%
  ggplot(aes(x = gender, y = m_age, fill = gender)) +
    geom_saberblade() +
    scale_fill_manual(values = c("#0FFF00", "#FF0000")) +
    scale_colour_manual(values = c("#0FFF00", "#FF0000")) +
    geom_saberhilt(column = 1) +
    geom_saberhilt(column = 2) +
    geom_text(aes(label = m_age_r, color = gender), 
              size = 6, 
              position = position_nudge(x = -.09, y = -8)) +
    labs(title = "Average age and gender",
           y = "Age (years)",
           x = "Gender",
           legend = "Gender",
           caption = "Data from https://swapi.co.") +
    my_theme() +
    coord_flip()
```

***

#### Description of Version Three

I like to think of this version of the plot as the [How to Draw A Horse](https://knowyourmeme.com/photos/572093-how-to-draw-an-owl) version, given its massive improvement over the previous plot. 

Again following the advice of [Daniel Anderson](https://github.com/datalorax), I used `coord_flip` to flip the x- and y-axes, drastically improving the look of the lightsabers. I assume the improvement is due partially to some innate preference for landscape orientation over portrait orientation, but, in any case, it allows the plot to neatly fit on a computer screen.

[Daniel](https://github.com/datalorax) also suggested I add annotations, which I added in the form of the means provided slightly below the blades. To achieve this, I used `position_nudge(x = -.09, y = -8)` to move the `geom_text` labels slightly below and slightly to the left of the actual means of the two groups.

I also created a simple black and pink (specifically "deeppink2") theme in a separate function script that I sourced at the beginning of the `R Markdown` document and added to this plot. The theme also bolds titles, axis titles, axis text, and captions. I also customized the major grid lines and completely removed the minor gridlines. Finally, I automatically suppressed the legend using `legend.position = "none"`. I did customize the legend to be consistent with the rest of the theme in case I decided to include it (e.g., [visualization 3][The Planets]).

### Version Four

```{r people_viz_v4}
# people plot
people %>%
  # filter for only females and males and drop the outlier (yoda)
  filter(gender == "female" | gender == "male",
         name   != "Yoda") %>%
  # group by gender
  group_by(gender) %>%
  # calculate mean age and rounded mean age for geom_text
  summarise(m_age   = mean(birth_year, na.rm = TRUE),
            m_age_r = round(m_age, 2),
            m_age_r = paste(m_age_r, "YEARS")) %>%
  # convert genders to title case and gender to a factor
  mutate(gender = str_to_title(gender),
         gender = as.factor(gender)) %>%
  # plot gender vs age and fill by gender
  ggplot(aes(x = gender, y = m_age, fill = gender)) +
    # add the lightsaber blades to the plot
    geom_saberblade() +
    # add the lightsaber hilts to the plot
    geom_saberhilt(column = 1) +
    geom_saberhilt(column = 2) +
    # set colour and fill values (i.e., red and green)
    scale_fill_manual(values   = c("#0FFF00", "#00f6ff")) +
    scale_colour_manual(values = c("#0FFF00", "#00f6ff")) +
    # add text with the mean ages to the plot
    geom_text(aes(label = m_age_r, color = gender), 
              size     = 6, 
              position = position_nudge(x = -.09, y = -6)) +
    # customize y-axis
    scale_y_continuous(breaks = c(0, 20, 40, 60)) +
    # add labels
    labs(title    = "Average Age of Characters by Gender",
         subtitle = "Excluding Yoda (for obvious reasons)",
         y        = "Age (years)",
         x        = "Gender",
         legend   = "Gender",
         caption  = "Data from https://swapi.co.") +
    # customize using my theme
    my_theme() +
    # flip the coordinates
    coord_flip()
```

*** 

#### Description of Version 4

In the (current) final plot of the characters' ages, I followed the advice of [Jon Rochelle](https://github.com/jrochel2) and [Maria Schweer-Collins](https://github.com/schweercollins) and changed the color of the lightsaber for males from red to blue. They suggested that the red colour would imply that this was representing the average age of male characters who had also succumbed to the Dark Side. I was initially wary of using blue to represent males as I usually try to avoid using the conventional colors to represent women and men, but I think in this case the use of blue is far less confusing. 

As noted by [Andrew Edelblum](https://github.com/AndrewEdelblum), Yoda is a major outlier at 896 years old. The only character who would seem to be even close to Yoda's age was Jabba Desilijic Tiure at 600 years old, but Jabba is hermaphroditic and was not included in the plot. In order to address Yoda's age, I simply dropped him from the plot and noted in the plot's subtitle that he was excluded. I did consider including a point to indicate where he was on the plot, but that would require an x-axis that spanned to around 900, which would seem to obscure any difference between the female and male lightsabers. 

[Andrew](https://github.com/AndrewEdelblum) and [Maria](https://github.com/schweercollins) also suggested that the title should read "age *by* gender" rather than "age *and* gender". They were completely correct, and I made the corresponding change.

Finally, I switched from using title case for the title and adjusted the x-axis limits using `scale_y_continuous` (scale_*y* since the coordinates were flipped).

# The Starships {.storyboard data-icon="fa-space-shuttle"}

### Version One

```{r starships_viz_v1}
# starships plot
starships %>%
  group_by(starship_class) %>%
  filter(!is.na(length),
         n() > 1) %>%
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  filter(!is.na(len_sd)) %>%
  mutate(len_se = len_sd / sqrt(len_n)) %>%
    ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
      geom_errorbar(aes(ymin = len_m - (len_se * 1.96), ymax = len_m + (len_se * 1.96)), 
                    width = .5) +
      geom_point(size = 5) +
      geom_point(size = 3, shape = 13, color = "grey80") +
      coord_flip() +
      theme_bw() +
      labs(title = "Average length of starship by ship class",
           y = "Average Length (meters)",
           x = "Ship class",
           caption = "Data from https://swapi.co.")
```

*** 

#### Intended Message

Overall, this plot is aimed at illustrating how starships from Star Wars differ in size. Specifically, I was trying to illustrate that Yachts are, by far, the largest ships with assault starfighters being slightly larger than basic starfighters. Yachts also have the most variable sizes among all of the starships. 

#### Intended Audience

Although the audience for this plot is generally the same as the previous plot (i.e., fans of Star Wars), I believe this plot is skewed far more towards those who are knowledgable enough about statistics to be able to interpret error bars. 

#### Description of Version One

Points and standard error bars have always looked like [Tie Fighters](https://en.wikipedia.org/wiki/TIE_fighter) to me, so I decided I would try to plot the length of a starship by starship class (i.e., Starfighters, Assault Starfighters, and Yachts). I excluded any class that only had one ship type in the dataset (e.g., Star Destroyers). To achieve the look I was going for, I plotted an error bar using `geom_errorbar` and then plotted a black `geom_point` for the ships hull and a grey, shape-13 `geom_point` for the ships' windows. 

### Version Two
```{r starships_viz_v2}
# create stars data
stars_data <- tibble(x     = sample(seq(from = 0,   to = 4,  by = .0001), 500),
                     y     = sample(seq(from = 0,   to = 80, by = .0001), 500),
                     trans = sample(seq(from = .1, to = .9,   by = .0001), 500))

# starships plot
starships %>%
  group_by(starship_class) %>%
  filter(!is.na(length),
         n() > 1) %>%
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  filter(!is.na(len_sd)) %>%
  mutate(len_se = len_sd / sqrt(len_n)) %>%
    ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
      geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                        ymax = len_m + (len_se * qnorm(.975))), 
                    width = .5, color = "grey30", lwd = 1.2) +
      geom_point(size = 5, color = "grey30") +
      geom_point(size = 2, color = "grey10") +
      geom_point(size = 3, shape = 13, color = "grey60") +
      geom_point(data = stars_data, aes(x = x, y = y, alpha = trans), 
                 color = "white",
                 size = .001) +
      coord_flip() +
      theme_bw() +
      theme(panel.background = element_rect(fill = "#000000")) +
      labs(title = "Average length of starship by ship class",
           y = "Average Length in Meters",
           x = "Ship class",
           caption = "Data from https://swapi.co.") + 
      scale_y_continuous(limits = c(0,80), expand = expand_scale(mult = c(0, 0)))
```

***
#### Description of Version Two

For the second version, I changed the ships' wings and hulls to a dark gray to more accurately reflect the look of a Tie Fighter. I also added a black `geom_point` between the windows' frames and the hulls to give the impression of glass.

In this stage, I also created random data to represent stars in the plot. To do this, I used `sample` (without replacement) to pick 500 values between the x-axis limits of 0 and 4, 500 values between the y-axis limits of 0 and 80, and 500 transparency values between .1 and .9. I then simply plotted these points in white using `geom_point`, mapping the x-axis to x, the y-axis to y, and the alpha to the transparency values.

To show the stars in this version, I retroactively added in a black background. The original plot had used the `new_retro` theme from the [vapoRwave](https://github.com/moldach/vapoRwave) package by Matthew Oldach [Matthew Oldach](https://github.com/moldach). Unfortunately, that theme used fonts that drastically limited reproducibility and was part of the impetus behind me creating my own theme. 

### Version Three
```{r starships_viz_v3}
# generate random x, y, and transparency data to use for plotting stars
stars_data <- tibble(x     = sample(seq(from =  0, to =  4, by = .0001), 500),
                     y     = sample(seq(from =  0, to = 80, by = .0001), 500),
                     trans = sample(seq(from = .1, to = .9, by = .0001), 500))
# starships plot
starships %>%
  # group by starship_class
  group_by(starship_class) %>%
  # drop rows that have an NA for length 
  filter(!is.na(length)) %>%
  # calculate mean length and standard deviation, as well as number of ships in 
  # that class
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  # retain classes that have more than one ship
  filter(len_n > 1) %>%
  # convert starship_class to title case and wrap multi-word levels
  mutate(starship_class = str_to_title(starship_class),
         starship_class = gsub(" ", " \n", starship_class)) %>%
  # calculate standard error
  mutate(len_se = len_sd / sqrt(len_n)) %>%
    # plot starship class v starship length
    ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
      # add error bars
      geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                        ymax = len_m + (len_se * qnorm(.975))), 
                    width = .5, colour = "grey30", lwd = 1.2) +
      # add stars 
      geom_point(data = stars_data, aes(x = x, y = y, alpha = trans), 
                 colour = "white",
                 size = .001) +
      # plot ship body points
      geom_point(size = 6, colour = "grey30") +
      geom_point(size = 3, colour = "grey10") +
      geom_point(size = 4, shape = 13, colour = "grey60") +
      # flip the coordinates
      coord_flip() +
      # add labels
      labs(title   = "Average length of starship by ship class",
           y       = "Average Length in Meters",
           x       = "Class",
           caption = "Data from https://swapi.co.") + 
      # set y-axis limits and do not show value beyond limits of y-axis
      scale_y_continuous(limits = c(0,80), 
                         expand = expand_scale(mult = c(0, 0))) + 
      # customize using my theme
      my_theme()
```

***

#### Description of Version Three

Version 3 involved mostly minor appearance changes. I added `my_theme` to make the theme consistent with my other visualizations and made the size of the ships' bodies larger to be more consistent with actual (fictional) Tie Fighters. I also added a `\n` between "Assault" and "Starfighter" in the y-axis labels so that "Assault Starfighter" did not take up substantially more horizontal space than the other labels.

### Version Four

```{r starships_viz_v4}
# generate random x, y, and transparency data to use for plotting stars
stars_data <- tibble(x     = sample(seq(from =  0, to =  4, by = .0001), 500),
                     y     = sample(seq(from =  0, to = 80, by = .0001), 500),
                     trans = sample(seq(from = .1, to = .9, by = .0001), 500))

# starships plot
starships %>%
  # group by starship_class
  group_by(starship_class) %>%
  # drop rows that have an NA for length 
  filter(!is.na(length)) %>%
  # calculate mean length and standard deviation, as well as number of ships in 
  # that class
  summarize(len_m  = mean(length),
            len_sd = sd(length),
            len_n  = n()) %>%
  # retain classes that have more than one ship
  filter(len_n > 1) %>%
  # convert starship_class to title case and wrap multi-word levels
  mutate(starship_class = str_to_title(starship_class),
         starship_class = gsub(" ", " \n", starship_class)) %>%
  # calculate standard error
  mutate(len_se = len_sd / sqrt(len_n)) %>%
  # plot starship class v starship length
  ggplot(aes(x = fct_reorder(starship_class, desc(len_m)), y = len_m)) +
    # add error bars
    geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                      ymax = len_m + (len_se * qnorm(.975))), 
                  width = .5, colour = "grey70", lwd = 1.25) +
    geom_errorbar(aes(ymin = len_m - (len_se * qnorm(.975)), 
                      ymax = len_m + (len_se * qnorm(.975))), 
                  width = .5, colour = "grey30", lwd = 1) +
    # add stars 
    geom_point(data = stars_data, aes(x = x, y = y, alpha = trans), 
               colour = "white",
               size = .001) +
    # plot ship body points
    geom_point(size = 6.70, colour = "grey70") +
    geom_point(size = 6.40, colour = "grey30") +
    geom_point(size = 4.40, colour = "grey10") +
    geom_point(size = 3.40, colour = "grey60", shape = 8) +
    geom_point(size = 4.40, colour = "grey60", shape = 1) +
    geom_point(size = 2.00, colour = "grey60") +
    geom_point(size = 1.50, colour = "grey10") +
    # flip the coordinates
    coord_flip() +
    # add labels
    labs(title    = "Average Length of Starship by Ship Class",
         subtitle = "Mean length indicated by ship body position\nConfidence interval (95%) indicated by wing span",
         y        = "Average Length in Meters",
         x        = "Class",
         caption  = "Data from https://swapi.co.") + 
    # set y-axis limits and do not show value beyond limits of y-axis
    scale_y_continuous(limits = c(0,80), 
                       expand = expand_scale(mult = c(0, 0))) + 
    # customize using my theme
    my_theme() +
    theme(plot.margin  = unit(c(1, 1, 1, 1), "cm"),
          axis.title.y = element_text(vjust = 5))
```

*** 

#### Description of Version Four

In this version of the starship plot, I completely reworked the body of the starships to more accurately reflect the look of Tie Fighters. I did this by adding three additional `geom_point` layers. In the end the body of the ship comprised (1) a large light gray layer to outline the hulls, (2) a slightly smaller dark gray layer to represent the hulls, (3) a black layer to represent the annular windows, (4) a light gray asterisk layer to represent the radial window frames, (5) a light gray layer to represent the outer window frame, (6) a light gray layer to represent the inner window frames, and (7) a black layer to represent the center windows.

As hinted at above and as per [Jon's](https://github.com/jrochel2) advice, I also added a thin layer of light gray around the ships body and wings to make the Tie Fighters pop from the starry background.

I did consider dropping the "class" y-axis title because the y-axis labels seemed intuitive to me; ultimately, I decided that the title might be helpful in aiding comprehension. Instead, I shifted the y-axis title away from the y-axis labels using `axis.title.y = element_text(vjust = 5)` so it wouldn't look as cramped. I also increased the plot margin on the right side of the plot so the text wasn't right up against the plot border. 

Following [Maria](https://github.com/schweercollins)'s advice, I also attempted to plot the mean and standard error of each ship as text on the plot, but it was hard to find an appropriate space to put them. One would imagine immediately underneath the ships would look good, but, given the differing width of the starships' wings, it ended up looking awkward. Instead, I added subtitles describing what the wings and the hull represent.

# The Planets {.storyboard data-icon="fa-globe-asia"}

### Version One

```{r planets_viz_v1, warning = FALSE}
# planets plot
planets %>%
  filter(area < mean(area, na.rm = TRUE) + (sd(area, na.rm = TRUE) * 3)) %>%
  ggplot(aes(x = au, y = surface_water, size = area)) +
    geom_point(alpha = .8, color = "yellow") +
    geom_smooth(method = "lm", se = FALSE, color = "yellow") +
    scale_color_gradient(high = "#0E0584", low = "#086703", na.value = "#AB8703") +
    theme(panel.background = element_rect(fill = "black"),
          panel.grid.major = element_line(size = .10),
          panel.grid.minor = element_line(size = .05)) +
    scale_y_continuous(labels = scales::percent) +
    xlim(.5,1.5) +
    labs(title = "Distance from the sun and amount of surface water",
         y = "Amount of surface water (%)",
         x = "Distance from star (Astronomical Units)",
         size = "Size",
         caption = "Data from https://swapi.co")

```

*** 

#### Intended Message

In the original version of this plot, I intended to illustrate that as a planet gets further from its star the amount of surface water decreases. This did seem to be the case, but I became more interested in the size of planets, orbital periods, and the distance of planets from their stars. In the end, the intent of the plot became illustrating that planets farther from their stars are both larger and orbit slower than those closer to their stars (and that this holds for planets in the Star Wars universe).

#### Intended Audience

Again, those interested in Star Wars would likely enjoy this plot. A general background in astronomy would also be helpful in interpreting the plot, but would not seem to be necessary. 

#### Description of Version One

The first version of this plot used the Star Wars colors (black and yellow) to show the relationship between the amount of water on a planet and the distance of those planets from their host stars. This relationship was illustrated using `geom_smooth` with the `method` set to `lm`. The planets were represented using `geom_point` and point size was mapped to the radii of the planets.

### Version Two

```{r planets_viz_v2, warning = FALSE}
# planets plot
planets %>%
  # select only variables of interest
  select(name, au, radius, solar_system) %>%
  # drop planets that do not have (1) a name, (2) a distance from the sun (i.e.
  # an AU), (3) an AU less than 2, and (4) a radius greater than 0.
  filter(!is.na(name),
         !is.na(au),
         # au < 2,
         radius       != 0.00,
         solar_system == FALSE) %>%
  # create a new variable indicating whether a planet was in the original 
  # trilogy
  mutate(orig_tril = case_when(name == "Alderaan" |
                               name == "Tatooine" |
                               name == "Yavin"    |
                               name == "Yavin 4"  ~ "new_hope",
                               name == "Bespin"   |
                               name == "Dagobah"  |                                 
                               name == "Hoth"     ~ "empire_strikes",                                
                               name == "Endor"    ~ "return_jedi",
                               TRUE ~ NA_character_)) %>%
  # sort the data by their distance from the sun
  arrange(au) %>%
  # add a column that arbitrarily assigns the planet a degree
  mutate(degree = seq(from = 1, to = 360, length.out = n())) %>%
  # plot the planets distance from the sun against their arbitrary degree
  ggplot(aes(x = degree, y = au)) +
    # add labels indicating y-axis units and add star and earth
    geom_text(aes(x =   0, y = 0, label = "STAR"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = 270, y = 2, label = "2 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = 270, y = 4, label = "4 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = 270, y = 6, label = "6 AU"), 
              color = "deeppink3", 
              size  = 7) +
    # add solar system planets
    geom_text(aes(x = 0, y = 1.00, label =   "EARTH"), 
      color = "deeppink3", 
      size  = 5) +
    geom_text(aes(x = 0, y = 1.52, label =    "MARS"), 
      color = "deeppink3", 
      size  = 5) +
    geom_text(aes(x = 0, y = 5.20, label = "JUPITER"), 
      color = "deeppink3", 
      size  = 5) +
    # add planet points; map size of the point to planet radius
    geom_point(aes(size = radius), alpha = .6, color = "#00ddff") +
    # make the coordinate polar
    coord_polar(theta = "x") +
    # set the limit of size values
    scale_size_continuous(range = c(.5, 10)) +
    # drop x-axis grid marks and breaks
    scale_x_continuous(breaks = NULL) +
    # set 2-axis limit
    scale_y_continuous(limits = c(0,7)) +
    # add labels
    labs(title    = "Distance of Star War's Planets from their Host Stars",
         subtitle = "in Astronomical Units (AU)", 
         caption  = "Data from https://swapi.co.") + 
    # customize using my theme
    my_theme() +
    # drop axis text and axis titles and center title, subtitle, and caption
    theme(plot.title    = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          plot.caption  = element_text(hjust = 0.5),
          axis.text     = element_blank(),
          axis.title    = element_blank(),
          plot.margin   = unit(c(1, 2, 1, 2), "cm")) +
    # add text identifying only those planetss from the original trilogy
    geom_label_repel(data = . %>% filter(!is.na(orig_tril)), aes(label = name),
                     color              = "#00ddff",
                     fill               =        NA,
                     size               =         8,
                     min.segment.length =         0,
                     nudge_y            =       2.1)
```

*** 

#### Description of Version Two

For the second plot, I dropped the interest in the amount of surface water the planet had and instead used `coord_polar` to show a top-down version of a star system with planets arbitrarily arranged around a star. As can be gleaned from the plot, it does seem that large planets (in this case, Bespin) are farther from their host stars than smaller planets.

I used a number of `geom_text` layers to add where solar system planets would sit on the plot for easy comparison. I also suppressed all axis labels and used `geom_text` to inset the axis labels inside the plot, rather than having them float outside the plot. Using `geom_label_repel` I added non-overlapping labels for the planets that appeared in the original trilogy. 

In a final step, I added my theme to this plot to make it consistent with the other plots. I also changed the color of the points to better complement the theme. 

### Version Three

```{r planets_viz_v3, warning = FALSE}
# create function for calculating x axis locations during the time it takes
# bespin to make one rotation. The slices have to be numerous to obscure the
# geom_points jumping back at the end of the year
orbit_slice <- function(planet = NULL) {
  temp <- planets$orbital_period[which(planets$name == planet)]
  rep(seq(from = 0, to = 5110, length.out = (511*(temp/5110))), 
      length.out = 511)
}
# calculate locations on the x-axis for each planets during the time it takes
# bespin to make one rotation. 
orbital_degrees <- tibble(
  "Alderaan"   = orbit_slice("Alderaan"),
  "Hoth"       = orbit_slice("Hoth"),
  "Dagobah"    = orbit_slice("Dagobah"),
  "Bespin"     = orbit_slice("Bespin"),
  "Endor"      = orbit_slice("Endor"),
  "Tatooine"   = orbit_slice("Tatooine"),
  "Mercury"    = orbit_slice("Mercury"),
  "Venus"      = orbit_slice("Venus"),
  "Earth"      = orbit_slice("Earth"),
  "Mars"       = orbit_slice("Mars"),
  "Jupiter"    = orbit_slice("Jupiter"),
  "days_count" = 1:511
)
# gather days into a column and the planet names into another column
orbital_degrees %<>%
  gather(key = "name", value = "days", -days_count)
# planets plot
plot3 <- planets %>%
  # select only variables of interest
  select(name, au, radius, orbital_period, orig_tril, solar_system) %>%
  # drop planets that do not have (1) a name, (2) a distance from the sun (i.e.
  # an AU), (3) an AU less than 2, and (4) a radius greater than 0.
  filter(!is.na(name),
         !is.na(au),
         !is.na(orbital_period),
         !is.na(orig_tril) | solar_system == TRUE,
         # au < 2,
         radius != 0.00) %>%
  left_join(orbital_degrees, by = "name") %>%
  # plot the planets distance from the sun against their arbitrary degree
  ggplot(aes(x = days, y = au, color = solar_system)) +
    # add labels indicating y-axis units and add star and earth
    geom_text(aes(x =   0, y = 0, label = "STAR"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = max(days) * 3/4, y = 2, label = "2 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = max(days) * 3/4, y = 4, label = "4 AU"), 
              color = "deeppink3", 
              size  = 7) +
    geom_text(aes(x = max(days) * 3/4, y = 6, label = "6 AU"), 
              color = "deeppink3", 
              size  = 7) +
    # add planet points; map size of the point to planet radius
    geom_point(aes(size = radius), alpha = .6) +
    # add planet text
    geom_text(aes(label = name), 
              position  = position_nudge(y = 1.1), 
              alpha     = .7) +
    # make the coordinate polar
    coord_polar(theta = "x") +
    # add transsition following days
    transition_time(days_count) +
    # set the limit of size values
    scale_size_continuous(range = c(.5, 10)) +
    # drop x-axis grid marks and breaks
    scale_x_continuous(breaks = NULL) +
    # set 2-axis limit
    scale_y_continuous(limits = c(0,7)) +
    # set the colours
    scale_colour_manual(values = c("#02fff6", "#ff5d00")) +
    # add labels
    labs(title    = "Distance of Star War's Planets from their Host Stars",
         subtitle = "Day: {(frame_time*10)}", 
         caption  = "Data from https://swapi.co.") + 
    # customize using my theme
    my_theme() +
    # drop axis text and axis titles and center title, subtitle, and caption
    theme(plot.title    = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          plot.caption  = element_text(hjust = 0.5),
          axis.text     = element_blank(),
          axis.title    = element_blank(),
          plot.margin   = unit(c(1, 7, 1, 7), "cm")) 

# animate the plot with a duration of 55 and a fps of 6
animate(plot3, 
        duration = 55,
        fps      = 12)
```

*** 

#### Description of Version Three

Following [Maria](https://github.com/schweercollins)'s advice, I dropped all the planets that are not in the original trilogy. This vastly simplified the plot and seemed to make it far easier to comprehend. Making it slightly more busy (but vastly aiding comparison) I also added the solar system planets as their own points, rather than having them represented by text.

Although not interactive (as per [Andrew](https://github.com/AndrewEdelblum)'s excellent suggestion), I animated the plot using `transition_time` from [Thomas Pedersen](https://github.com/thomasp85)'s [gganimate](https://github.com/thomasp85/gganimate). I believe the animation effectively illustrates the orbital period of the planets in an easily interpretable way. I also added a subtitle to show the number of days that pass, ranging from 0 to 5110 (i.e., the length of Bespin's orbit)

In order to have planets with orbits less than 5110 days continue orbiting once they had completed their orbit, I made a function called `orbital_slice` to generate the position of each planet at 511 time points during Bespin's 5110-day orbit. However, this presented a major problem: Once a planet had finished its orbit, instead of continuing forward from 359 degrees to 0 degrees, it would orbit backwards, returning to 0, before it continued forward again.

### Version Four

```{r planets_viz_v4, warning = FALSE}
# create function for calculating x axis locations during the time it takes
# bespin to make one rotation. There has to be enough slices to obscure the
# geom_points jumping back at the end of Bespin's year
orbit_slice <- function(planet = NULL) {
  # grab orbital period of planet of interest
  temp <- planets$orbital_period[which(planets$name == planet)]
  # calculate 511 x-axis point for that planet throughout Bespin' year
  rep(seq(from         = 0, 
            to         = 5110, 
            length.out = (5110 * (temp / 5110))),
      length.out = 5110)
}

# calculate locations on the x-axis for each planets during the time it takes
# bespin to make one rotation. 
orbital_degrees <- tibble(
  "Alderaan"   = orbit_slice("Alderaan"),
  "Hoth"       = orbit_slice("Hoth"),
  "Dagobah"    = orbit_slice("Dagobah"),
  "Bespin"     = orbit_slice("Bespin"),
  "Endor"      = orbit_slice("Endor"),
  "Tatooine"   = orbit_slice("Tatooine"),
  "Mercury"    = orbit_slice("Mercury"),
  "Venus"      = orbit_slice("Venus"),
  "Earth"      = orbit_slice("Earth"),
  "Mars"       = orbit_slice("Mars"),
  "Jupiter"    = orbit_slice("Jupiter"),
  "days_count" = 1:5110
)

# gather days into a column and the planet names into another column
orbital_degrees %<>%
  gather(key = "name", value = "days", -days_count)

# planets plot
planets_plot <- planets %>%
  # select only variables of interest
  select(name, au, radius, orbital_period, orig_tril, solar_system) %>%
  # drop planets that do not have (1) a name, (2) a distance from the sun (i.e.
  # an AU), (3) an AU less than 2, and (4) a radius greater than 0.
  filter(!is.na(name),
         !is.na(au),
         !is.na(orbital_period),
         !is.na(orig_tril) | solar_system == TRUE,
         # au < 2,
         radius != 0.00) %>%
  left_join(orbital_degrees, by = "name") %>%
  #drop mercury and alderaan
  filter(name != "Mercury", # mercury for orbiting too quickly
         name != "Alderaan") %>% # alderaan for esssentially being earth 2.0
  # plot the planets distance from the sun against their arbitrary degree
  ggplot(aes(x = days, y = au, color = solar_system)) +
    # add labels indicating y-axis units and add star and earth
    geom_text(aes(x =   0,          y = 0, label = "STAR"), 
              color = "deeppink3", 
              size  = 5) +
    geom_text(aes(x = 5110 * 3 / 4, y = 2, label = "2 AU"), 
              color = "deeppink3", 
              size  = 5) +
    geom_text(aes(x = 5110 * 3 / 4, y = 4, label = "4 AU"), 
              color = "deeppink3", 
              size  = 5) +
    geom_text(aes(x = 5110 * 3 / 4, y = 6, label = "6 AU"), 
              color = "deeppink3", 
              size  = 5) +
    # add label for describing 1 AU
    annotate(geom  =                   "label", 
             x     =             5110 * 1 / 2,
             y     =                        7,
             label = "1 AU = ~150,000,000 km", 
             color =              "deeppink2",
             fill  =                  "black",
             size  =                        5) +
    # add planet points; map size of the point to planet radius
    geom_point(aes(size = radius), alpha = .6) +
    # add planet text; also suppress its legend
    geom_text(aes(label   = name), 
              position    = position_nudge(y = 1.1), 
              alpha       = .7,
              size        =  5,
              show.legend = FALSE) +
    # make the coordinate polar
    coord_polar(theta = "x") +
    # add transition according to days
    transition_manual(days_count) +
    # set the limit of size values
    scale_size_continuous(range = c(.5, 10)) +
    # drop x-axis grid marks and breaks
    scale_x_continuous(breaks = NULL) +
    # set 2-axis limit
    scale_y_continuous(limits = c(0, 7)) +
    # set the colours
    scale_colour_manual(name   = "Star System",
                        values = c("#02fff6", "#ff7b00"),
                        labels = c("Solar System", "Star Wars")) +
    # add labels
    labs(title    = "The Orbital Periods and Distances from Host Stars of Planets",
         subtitle =                         "Days: {current_frame}", 
         caption  =                "Data from https://swapi.co.") +
    # customize using my theme
    my_theme() +
    # drop axis text and axis titles and center title, subtitle, and caption
    theme(plot.title      = element_text(hjust = 0.5),
          plot.subtitle   = element_text(hjust = 0.5),
          plot.caption    = element_text(hjust = 0.5),
          axis.text       = element_blank(),
          axis.title      = element_blank(),
          plot.margin     = unit(c(1, 4, 1, 7), "cm"),
          legend.position = "right") +
    # drop radius legend and change the size of the legend points
    guides(size = FALSE,
           colour = guide_legend(override.aes = list(size  = 5,
                                                     alpha = 1)))

# animate plot with a duration of 55 and a fps of 12
animate(planets_plot,
        nframes  = 12 * 55,
        fps      = 12)



``` 

*** 

#### Description of Version Four

As noted in the description of the previous plot, a major problem with using `transition_time` with repeating orbital data is that each planet, at the end of its orbit, will travel backwards from 359 degrees to 0 degrees. My first solution was to insert an `NA` in the data; the planet would briefly disappear at 359 degrees and then reappear at 0 degrees. However, even at an incredibly high number of slices, the flickering of the planets was noticeable. 

My solution came when I switched from using `transition_time` to using `transition_manual`. I still had to use a large number of slices since I am manually creating the movement from one frame to the next but the effect was far smoother and no flickering occurred.

For this plot, I also ended up having to drop "Alderaan"; it was orbiting at the same speed and at the same distance from its star as the Earth. I decided that the Earth was a far more important point of comparison than Alderaan. 

Finally, to increase interpretability, I added a `geom_label`, inset in the plot, describing the number of kilometers that an AU represents, and a legend describing what color of planets come from the Solar System and what color of planets come from the Star Wars universe. 
